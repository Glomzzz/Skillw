---
title: Prolog 教程 基础
date: 2022-07-13T18:00
author: Glom_
---
## 前言

> 本教程部分摘录自《七周七语言》  

**Prolog**是一门**逻辑**编程语言，它于1972年由[Alain Colmerauer](https://zhuanlan.zhihu.com/p/432871713)和[Phillipe Roussel](https://zhuanlan.zhihu.com/p/432871713)开发完成，在**自然语言处理领域**(NLP)颇受欢迎.  
现在，从调度系统到专家系统，这门备受尊重的语言为各类问题提供了编程基础，  
你可以使用这门基于规则的语言来表达逻辑和提出问题.
<!-- truncate -->
和**SQL**一样:

- **Prolog**基于数据库，但是其数据由逻辑规则和关系组成
- **Prolog**包含两个部分：一部分用于描述数据，而另一部分则用于查询数据

在**Prolog**中，数据以逻辑规则的形式存在，下面是基本构建单元.  

- **事实**. 事实是关于真实世界的基本断言.  （Babe是一头猪，猪喜欢泥巴. ）
- **规则**. 规则是关于真实世界中一些事实的推论.  （如果一个动物是猪，那么它喜欢泥巴. ）
- **查询**. 查询是关于真实世界的一个问题.  （Babe喜欢泥巴吗？）
事实和规则被放入一个**知识库**中. **Prolog**编译器会将这个**知识库**编译成一种适于高效查询的形式.  
当我们学习这些例子的时候，你可以使用**Prolog**表达知识库.  
然后你就可以直接检索数据，也可以使用**Prolog**将多个规则串联在一起来得到一些你可能不知道的事情.  
关于**Prolog**的背景介绍已经足够多了. 让我们开始正式的学习吧.  

关于配置开发环境，搜索引擎上就有，不赘述了。

## 基本构建单元

在一些语言中，大写字母如何使用完全由程序员自行决定。不过在**Prolog**中，**第一个字母的大小写**是有着重要意义的：

- 如果一个词以**小写字母**开头，那么它就是一个**常量**
- 如果一个词以**大写字母**或**下划线**开头，那么它就是一个**变量**。

让我们用一些事实来构建一个简单的知识库吧。

> types.pl

```prolog
% 我是注释

move(dog).
breath(dog).
like(dog,flower).

move(cat).
breath(cat).
like(cat,flower).
like(cat,grass).

breath(grass).
breath(flower).

plant(X) :- \+ move(X), breath(X).
animal(X) :- move(X), breath(X).
friend(X,Y) :- \+ (X=Y), like(X,Z), like(Y,Z).


```  

上述代码是由**事实**和**规则**组成的**知识库**。  
前几行语句是**事实**，最后两行语句是一个**规则**。
**事实**是我们对这个世界直接观察的结果。  
**规则**是关于现实世界的逻辑推论。  
现在，注意前几行语句。其中每一行都是一个**事实**:

- 狗可以移动与呼吸, 喜欢花
- 猫可以移动与呼吸, 喜欢花和草
- 草可以呼吸
- 花可以呼吸

那么, 让我们进入编译器中, 输入`['types.pl']`, 此时解释器会编译知识库.
除非**Prolog**在等待一个中间结果，否则它都会用**yes**或**no**作出回应。  (true 或 false 同理)

- 输入 `move(cat)` , 输出 **yes**
- 输入 `breath(dog)` , 输出 **yes**
- 输入 `move(grass)` , 输出 **no**

这些问题都非常直观, **Prolog**仅仅是鹦鹉学舌般地将事实重新呈现给你。  
当你开始加入一些逻辑时，它才会变得更为精彩。让我们看看一些推论吧。  

- 输入 `plant(grass)`, 输出 **yes**
- 输入 `animal(grass)`, 输出 **no**
- 输入 `friend(dog,cat)`, 输出 **yes**
- 输入 `friend(cat,dog)`, 输出 **yes**

这样，**Prolog**就根据设置的规则来回答**yes**或**no**的问题，这里远比外表看起来的有深度。
看一下`plant`规则：
看看`:-`右边的第一部分吧，这部分被称为一个**子目标**。  
`\+`执行逻辑取反操作，这样`\+ move(X)`的意思就是`X不会移动`。  
只有`X`**不会动**且**会呼吸**时，它才是植物.  

再看一下`friend`规则:  
在规则中，如果`X`不与`Y`相同，且他们喜欢同一个事物，那么`X`与`Y`互为朋友。  

- 输入 `friend(cat,flower)`, 输出 **no**

现在让我们正式地介绍一下**规则的定义**:  

```prolog
friend(X,Y) :- \+ (X=Y), like(X,Z), like(Y,Z).
```

上述代码是一个具有三个变量`X`、`Y`和`Z`的****Prolog**规则**。我们把这个规则称作**friend/2**，即有两个参数的**friend规则**的缩写。  
这个规则拥有三个用逗号分隔的**子目标**。当所有子目标都为真时，这个规则才为真。  
所以我们这个规则的含义是：**如果X与Y不等同且X和Y都喜欢同一个Z，那么X是Y的朋友。**  


## 填空

我们用**Prolog**回答了一些**yes**或**no**的问题，不过我们能做的可不止这些。  
在这一节中，我们将使用**逻辑引擎**为一个查询找出所有可能的匹配。要做到这一点，你需要在查询中指定一个变量。  

> food.pl

```prolog

type(sausage,meat).
type(beaf,meat).
type(cake,dessert).
type(candy,dessert).
type(cola,soda).

flavor(savory,meat).
flavor(sweet,dessert).
flavor(sweet,soda).

food(X,Y) :- type(X,Z), flavor(Y,Z).

```
我们给出了一些事实。诸如`type(sausage, meat)`，意思是一种食物具有一定的类型。  
另外一些诸如`flavor(sweet, dessert)`，意思是一种食物类型具有特有的味道。  
最后，我们出了一个名为**food**的规则，它可推断出食物的味道。  
如果食物`X`属于`Z`类食物且`Z`也具有特有味道`Y`，则食物`X`是`Y`食物。  

让我们进入编译器中, 输入`['food.pl']`。  

```bash


?- type(What,meat).
What = sausage ;
What = beaf.

```

现在很有趣。我们请求**Prolog**，“找出一些满足查询food(What, savory)的值。”**Prolog**找到了一个sausage。输入;，请求**Prolog**找出下一个，它返回了beaf。  
由于这些查询依赖**基本事实**，所以值很容易找到。再试试:

```bash
?- food(What,sweet).
What = cake ;
What = candy ;
What = cola.
```

记住，`food(X, Y)`是一个规则，不是一个事实。我们请求**Prolog**找出满足“什么食物是savory？”这个查询的所有可能值。  
**Prolog**必须将关于食物、类型和味道的基本事实联系在一起才能得出最终结论。  
**逻辑引擎需要遍历所有使目标为真的可能组合。**

### 地图着色问题

经典的高中题。  

[map-color](images/map-color.png)

下面用同样的思路来进行地图着色。为了更深入地观察**Prolog**，我们采用了这个例子。  
这里要给上面的地图着色，填充图中所展示的各区域。我们不想两个接壤的区域具有相同颜色。  

> map.pl

```prolog
color(red).
color(green).
color(blue).

colorify(A,B,C,D,E) :-
    color(A), color(B), color(C), color(D), color(E),
    \+ A=B, \+ A=C, \+ A=D, \+ A=E,
    \+ B=C, \+ C=D, \+ D=E.
```

加载**map.pl**并执行表达式`colorify(A,B,C,D,E)`，**Prolog** 就会将三种颜色依次赋值给变量，测试哪些组合是可能的结果。  

```bash
?- colorify(A,B,C,D,E).
A = red,
B = D, D = green,
C = E, E = blue;
A = red,
B = D, D = blue,
C = E, E = green ;
A = green,
B = D, D = red,
C = E, E = blue ;
A = green,
B = D, D = blue,
C = E, E = red ;
A = blue,
B = D, D = red,
C = E, E = green ;
A = blue,
B = D, D = green,
C = E, E = red ;
```

果然，有一种方法可以使用三种颜色对这五个区域进行着色。你也可以通过输入`;`得到另外几种着色组合。通过不到十行代码，我们就完成了地图着色。  
这个逻辑非常简单，即便是小孩子都可以理解。某个时候，你要问自己……  

### 程序在哪?

我们没有使用算法！试试选一门**过程式编程语言**来解决这个问题。你的解决方法容易理解吗？考虑一下如果用**Java**或**Javascript**来解决这样复杂的逻辑问题你需要做些什么？  
一个可能的解决方法如下：  
(1) 收集和整理逻辑；  
(2) 用程序表达逻辑；  
(3) 找出所有可能的解决方法；  
(4) 通过程序验证这些可能的解决方法。  
你可能不得不一遍又一遍地去编写程序。**Prolog**让你通过事实和推论来表达逻辑，然后直接提问即可。  
你不必用这门语言去制作任何具有详细步骤的烹饪食谱。  
**Prolog**不是通过编写算法来解决逻辑问题的，而是通过如实地描述真实世界，来呈现计算机可以设法解决的逻辑问题。  
让计算机做这些工作吧！  